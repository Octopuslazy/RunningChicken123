#!/usr/bin/env node
import fs from 'fs/promises';
import path from 'path';

const ASSETS_DIR = path.resolve(process.cwd(), 'Assets');
const OUT_FILE = path.resolve(process.cwd(), 'src', 'inlinedAssets.ts');

const MIME = {
  png: 'image/png',
  jpg: 'image/jpeg',
  jpeg: 'image/jpeg',
  webp: 'image/webp',
  gif: 'image/gif',
  mp3: 'audio/mpeg',
  wav: 'audio/wav',
  ogg: 'audio/ogg',
  mp4: 'video/mp4',
  webm: 'video/webm',
  ttf: 'font/ttf',
  woff: 'font/woff',
  woff2: 'font/woff2',
  json: 'application/json',
  txt: 'text/plain'
};

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) files.push(...await walk(full));
    else files.push(full);
  }
  return files;
}

function toAssetKey(fullPath) {
  // produce relative path from project root, using forward slashes
  const rel = path.relative(process.cwd(), fullPath).replace(/\\/g, '/');
  return rel.startsWith('./') ? rel.slice(2) : rel;
}

function mimeFor(name) {
  const ext = name.split('.').pop().toLowerCase();
  return MIME[ext] || 'application/octet-stream';
}

async function main() {
  try {
    const files = await walk(ASSETS_DIR);
    const map = {};
    for (const f of files) {
      const key = toAssetKey(f);
      const buf = await fs.readFile(f);
      // Convert binary to base64 string (without data URI prefix)
      const base64String = buf.toString('base64');
      map[key] = base64String;
    }

    // output TS file
    const lines = [];
    lines.push('// AUTO-GENERATED by scripts/generate-inlined-assets.mjs');
    lines.push('// Do not edit by hand.');
    lines.push('');
    lines.push('export const INLINED_ASSETS: Record<string,string> = {');
    for (const k of Object.keys(map).sort()) {
      lines.push(`  ${JSON.stringify(k)}: ${JSON.stringify(map[k])},`);
    }
    lines.push('};');
    lines.push('');
    lines.push('if (typeof window !== "undefined") {');
    lines.push('  // make available as a global for runtime checks');
    lines.push('  (window as any).__INLINED_ASSETS__ = INLINED_ASSETS;');
    lines.push('}');
    lines.push('');

    await fs.mkdir(path.dirname(OUT_FILE), { recursive: true });
    await fs.writeFile(OUT_FILE, lines.join('\n'));
    console.log(`Wrote inlined assets to ${OUT_FILE} (${Object.keys(map).length} files)`);
  } catch (err) {
    console.error('Failed to generate inlined assets:', err);
    process.exitCode = 1;
  }
}

main();
